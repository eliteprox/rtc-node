<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>RTC Stream Preview</title>
<style>
  :root {
    color-scheme: dark;
    font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
  }

  body {
    margin: 0;
    background: transparent;
    color: #f5f5ff;
  }

  .preview-shell {
    width: 100%;
    max-width: 520px;
    margin: 0 auto;
    padding: 0 6px 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .header-block {
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 2px 0;
  }

  .video-frame {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: 12px;
    border: 1px solid #1c1c24;
    background: #030304;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  video {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #050506;
  }

  .title {
    font-size: 0.95rem;
    font-weight: 600;
  }

  .subtitle {
    font-size: 0.75rem;
    color: #8d8fa7;
  }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #3e3e4d;
  }

  .status-dot.connected {
    background: #4ada9d;
  }

  .status-dot.connecting {
    background: #f0b429;
  }

  .status-dot.error {
    background: #ff5f5f;
  }

  .status-strip {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.78rem;
    color: #a0a1ba;
    padding: 4px 0;
  }

  .status-pill {
    color: inherit;
    flex: 1;
  }

  .status-pill.connected {
    color: #c2ffe3;
  }

  .status-pill.connecting {
    color: #f0b429;
  }

  .status-pill.error {
    color: #ff8a8a;
  }

  .controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .button-group {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  button {
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-weight: 600;
    cursor: pointer;
    background: #4646f4;
    color: #fff;
    font-size: 0.85rem;
    transition: all 0.2s ease;
  }

  button:hover:not(:disabled) {
    opacity: 0.9;
    transform: translateY(-1px);
  }

  button.secondary {
    background: #2a2a34;
    color: #d6d8ef;
  }

  button.success {
    background: #2fbb6f;
    color: #fff;
  }

  button.danger {
    background: #ff5f5f;
    color: #fff;
  }

  button.small {
    padding: 4px 10px;
    font-size: 0.8rem;
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .info-strip {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
    font-size: 0.78rem;
    color: #8d8fa7;
  }

  .info-field {
    display: flex;
    gap: 6px;
    align-items: baseline;
  }

  .info-label {
    text-transform: uppercase;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    color: #74768c;
  }

  .info-value {
    font-size: 0.85rem;
    color: #f5f5ff;
  }

  .lvpr-link {
    margin-left: auto;
    font-size: 0.8rem;
    color: #8ab4ff;
    text-decoration: none;
  }

  .lvpr-link.disabled {
    opacity: 0.4;
    pointer-events: none;
    cursor: default;
  }
</style>
</head>
<body>
  <div class="preview-shell">
    <!-- <div class="header-block">
      <div class="title">RTC Stream Preview</div>
      <div class="subtitle">Live playback via WHEP</div>
    </div> -->

    <div class="video-frame">
      <video id="previewVideo" playsinline autoplay muted controls></video>
    </div>

    <div class="controls">
      <button id="streamToggleBtn" class="success small">Start Stream</button>
      <button id="connectionToggleBtn" class="small">Connect</button>
      <a
        id="lvprLink"
        class="lvpr-link disabled"
        href="#"
        target="_blank"
        rel="noreferrer noopener"
      >
        lvpr.tv link unavailable
      </a>
    </div>

    <div class="status-strip">
      <span class="status-dot" id="statusDot"></span>
      <span class="status-pill" id="connectionState">idle</span>
    </div>

    <div class="info-strip">
      <div class="info-field">
        <span class="info-label">Stream ID</span>
        <span class="info-value" id="streamIdField">—</span>
      </div>
      <div class="info-field">
        <span class="info-label">Playback ID</span>
        <span class="info-value" id="playbackIdField">—</span>
      </div>
    </div>
  </div>

  <script>
    (async () => {
      const queryParams = new URLSearchParams(window.location.search);

      const normalizeBase = (value) => (value || "").trim().replace(/\/+$/, "");
      const storedBase = normalizeBase(window.localStorage.getItem("rtcPreview.localBase"));
      const queryBase = normalizeBase(queryParams.get("base"));
      const fallbackBase = window.location.protocol.startsWith("http")
        ? `${window.location.protocol}//${window.location.hostname || "127.0.0.1"}:8895`
        : "http://127.0.0.1:8895";
      let baseUrl = queryBase || storedBase || fallbackBase;
      window.localStorage.setItem("rtcPreview.localBase", baseUrl);

      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun.cloudflare.com:3478" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun2.l.google.com:19302" },
        { urls: "stun:stun3.l.google.com:19302" },
      ];

      const elements = {
        streamToggleBtn: document.getElementById("streamToggleBtn"),
        connectionToggleBtn: document.getElementById("connectionToggleBtn"),
        video: document.getElementById("previewVideo"),
        streamIdField: document.getElementById("streamIdField"),
        playbackIdField: document.getElementById("playbackIdField"),
        connectionState: document.getElementById("connectionState"),
        lvprLink: document.getElementById("lvprLink"),
        statusDot: document.getElementById("statusDot"),
      };

      let isStreamRunning = false;
      let isConnected = false;

      let peerConnection = null;
      let mediaStream = null;
      let connecting = false;
      let currentWhepUrl = "";
      let statusTimer = null;
      let syncBasePromise = null;

      async function syncLocalApiBase() {
        if (syncBasePromise) {
          return syncBasePromise;
        }
        syncBasePromise = (async () => {
          const response = await fetch("/rtc/control", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "start" }),
            cache: "no-store",
          });
          if (!response.ok) {
            throw new Error(`RTC control HTTP ${response.status}`);
          }
          const payload = await response.json();
          const status = payload?.status || {};
          if (!status.running) {
            const message = payload?.error || "Local API server unavailable";
            throw new Error(message);
          }
          const host = status.host || "127.0.0.1";
          const port = status.port ?? 8895;
          const nextBase = `http://${host}:${port}`;
          if (baseUrl !== nextBase) {
            baseUrl = nextBase;
            window.localStorage.setItem("rtcPreview.localBase", baseUrl);
          }
          return status;
        })();
        try {
          return await syncBasePromise;
        } finally {
          syncBasePromise = null;
        }
      }

      function updateStreamButton(running, busy = false) {
        isStreamRunning = running;
        if (busy) {
          elements.streamToggleBtn.disabled = true;
          elements.streamToggleBtn.textContent = running ? "Stopping..." : "Starting...";
        } else {
          elements.streamToggleBtn.disabled = false;
          if (running) {
            elements.streamToggleBtn.textContent = "Stop Stream";
            elements.streamToggleBtn.className = "danger small";
          } else {
            elements.streamToggleBtn.textContent = "Start Stream";
            elements.streamToggleBtn.className = "success small";
          }
        }
      }

      function updateConnectionButton(connected, busy = false) {
        isConnected = connected;
        if (busy) {
          elements.connectionToggleBtn.disabled = true;
          elements.connectionToggleBtn.textContent = "Connecting...";
        } else {
          elements.connectionToggleBtn.disabled = false;
          if (connected) {
            elements.connectionToggleBtn.textContent = "Disconnect";
            elements.connectionToggleBtn.className = "secondary small";
          } else {
            elements.connectionToggleBtn.textContent = "Connect";
            elements.connectionToggleBtn.className = "small";
          }
        }
      }

      function setConnectionState(state, detail = "") {
        const label = detail ? `${state} · ${detail}` : state;
        elements.connectionState.textContent = label;
        elements.connectionState.className = "status-pill";
        elements.statusDot.className = "status-dot";
        if (state === "connected") {
          elements.connectionState.classList.add("connected");
          elements.statusDot.classList.add("connected");
        } else if (state === "error") {
          elements.connectionState.classList.add("error");
          elements.statusDot.classList.add("error");
        } else if (state === "connecting") {
          elements.connectionState.classList.add("connecting");
          elements.statusDot.classList.add("connecting");
        }
      }

      function cleanupStream() {
        if (mediaStream) {
          mediaStream.getTracks().forEach((track) => track.stop());
          mediaStream = null;
        }
        elements.video.srcObject = null;
      }

      function disconnectPeer(reason = "", { preserveConnectButton = false } = {}) {
        if (peerConnection) {
          try {
            peerConnection.ontrack = null;
            peerConnection.onconnectionstatechange = null;
            peerConnection.close();
          } catch {
            // ignore close errors
          }
          peerConnection = null;
        }
        cleanupStream();
        if (!preserveConnectButton) {
          updateConnectionButton(false);
        }
        if (!connecting) {
          setConnectionState("idle");
        }
      }

      function updateLvprLink(playbackId) {
        if (playbackId) {
          const lvprUrl = `https://lvpr.tv?v=${encodeURIComponent(playbackId)}`;
          elements.lvprLink.href = lvprUrl;
          elements.lvprLink.textContent = "Open lvpr.tv";
          elements.lvprLink.classList.remove("disabled");
        } else {
          elements.lvprLink.href = "#";
          elements.lvprLink.textContent = "lvpr.tv link unavailable";
          elements.lvprLink.classList.add("disabled");
        }
      }

      function updateMetadata(statusPayload) {
        const streamId = (statusPayload && statusPayload.stream_id) || "—";
        const playbackId = (statusPayload && statusPayload.playback_id) || "—";
        const running = statusPayload && statusPayload.running;
        
        elements.streamIdField.textContent = streamId;
        elements.playbackIdField.textContent = playbackId;
        updateLvprLink(playbackId !== "—" ? playbackId : "");
        
        // Update stream toggle button based on running state
        updateStreamButton(!!running);
      }

      function extractWhepUrl(status) {
        if (!status || typeof status !== "object") {
          return "";
        }
        if (typeof status.whep_url === "string" && status.whep_url) {
          return status.whep_url;
        }
        const remote = status.remote_status;
        const fromRemote = tryGateway(remote && remote.body ? remote.body : remote);
        if (fromRemote) {
          return fromRemote;
        }
        const nested = tryGateway(status);
        if (nested) {
          return nested;
        }
        if (typeof status.whip_url === "string") {
          return status.whip_url;
        }
        return "";
      }

      function tryGateway(payload) {
        if (!payload || typeof payload !== "object") {
          return "";
        }
        if (payload.success === true && payload.error == null) {
          const data = payload.data || {};
          if (data.gateway_status && typeof data.gateway_status.whep_url === "string") {
            return data.gateway_status.whep_url;
          }
        }
        if (payload.data && typeof payload.data.whep_url === "string") {
          return payload.data.whep_url;
        }
        return "";
      }

      async function refreshStatus({ attemptConnect = false, autoConnect = false } = {}) {
        try {
          const response = await fetch(`${baseUrl}/status`, { method: "GET", cache: "no-store" });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          updateMetadata(data);
          const whepFromStatus = extractWhepUrl(data);
          if (whepFromStatus) {
            currentWhepUrl = whepFromStatus;
          }
          if ((attemptConnect || autoConnect) && !peerConnection && !connecting) {
            if (!currentWhepUrl) {
              if (!autoConnect) {
                throw new Error("No WHEP URL in status");
              }
            } else {
              await connectToWhep(currentWhepUrl);
            }
          }
          return data;
        } catch (error) {
          if (!attemptConnect) {
            updateMetadata({});
          }
          throw error;
        }
      }

      function startStatusPolling() {
        if (statusTimer) {
          clearInterval(statusTimer);
        }
        statusTimer = setInterval(() => {
          refreshStatus({ autoConnect: true }).catch(() => {});
        }, 8000);
      }

      async function startStream() {
        try {
          updateStreamButton(false, true);
          setConnectionState("connecting", "starting stream");

          await syncLocalApiBase();
          
          const payload = {
            stream_name: "comfyui-livestream",
            pipeline_config: {},
            frame_rate: 30,
            frame_width: 512,
            frame_height: 512
          };
          
          const response = await fetch(`${baseUrl}/start`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            cache: "no-store"
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          setConnectionState("idle", "stream started");
          
          // Refresh status to update UI
          await refreshStatus({ autoConnect: true });
          
        } catch (error) {
          setConnectionState("error", error.message || "start failed");
          updateStreamButton(false);
        }
      }

      async function stopStream() {
        try {
          updateStreamButton(true, true);
          setConnectionState("connecting", "stopping stream");
          
          const response = await fetch(`${baseUrl}/stop`, {
            method: "POST",
            cache: "no-store"
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          setConnectionState("idle", "stream stopped");
          
          // Disconnect preview if connected
          if (peerConnection) {
            disconnectPeer("stream stopped");
          }
          
          // Refresh status to update UI
          await refreshStatus();
          
        } catch (error) {
          setConnectionState("error", error.message || "stop failed");
          updateStreamButton(true);
        }
      }

      async function connectToWhep(targetUrl) {
        if (connecting) {
          return;
        }
        const target = (targetUrl || "").trim();
        if (!target) {
          setConnectionState("error", "Missing WHEP URL");
          return;
        }

        connecting = true;
        updateConnectionButton(false, true);
        setConnectionState("connecting");
        disconnectPeer("switching", { preserveConnectButton: true });

        const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        peerConnection = pc;
        pc.addTransceiver("video", { direction: "recvonly" });

        pc.ontrack = (event) => {
          const [stream] = event.streams;
          mediaStream = stream || new MediaStream([event.track]);
          elements.video.srcObject = mediaStream;
        };

        pc.onconnectionstatechange = () => {
          const state = pc.connectionState || "unknown";
          if (state === "failed" || state === "disconnected") {
            disconnectPeer(state);
          } else if (state === "connected") {
            updateConnectionButton(true);
            setConnectionState("connected");
          }
        };

        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          const response = await fetch(target, {
            method: "POST",
            headers: { "Content-Type": "application/sdp" },
            body: pc.localDescription.sdp,
            mode: "cors",
          });
          if (!response.ok) {
            throw new Error(`WHEP HTTP ${response.status}`);
          }
          const answer = await response.text();
          const remoteDesc = { type: "answer", sdp: answer };
          await pc.setRemoteDescription(remoteDesc);
          updateConnectionButton(true);
          setConnectionState("connected");
        } catch (error) {
          setConnectionState("error", error.message || "connection failed");
          disconnectPeer("failed");
          throw error;
        } finally {
          connecting = false;
          if (!peerConnection) {
            updateConnectionButton(false);
          }
        }
      }

      function wireEvents() {
        elements.streamToggleBtn.addEventListener("click", () => {
          if (isStreamRunning) {
            stopStream();
          } else {
            startStream();
          }
        });

        elements.connectionToggleBtn.addEventListener("click", async () => {
          if (isConnected || peerConnection) {
            disconnectPeer("manual");
          } else {
            if (connecting) {
              return;
            }
            updateConnectionButton(false, true);
            try {
              await refreshStatus({ attemptConnect: true });
            } catch (error) {
              setConnectionState("error", error.message || "status failed");
            } finally {
              if (!peerConnection && !connecting) {
                updateConnectionButton(false);
              }
            }
          }
        });

        window.addEventListener("beforeunload", () => disconnectPeer("unload"));
      }

      // Initialize: fetch status and auto-connect if stream is running
      try {
        await syncLocalApiBase();
      } catch (error) {
        console.warn("RTC preview unable to sync local API base:", error);
      }
      refreshStatus({ autoConnect: true }).catch(() => {});
      startStatusPolling();
      wireEvents();
    })();
  </script>
</body>
</html>


